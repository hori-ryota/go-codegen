package structdef

import (
	"bytes"
	"fmt"
	"go/token"
	"go/types"
	"io"
	"strings"
	"text/template"

	"github.com/hori-ryota/go-codegen/util/typeutil"
	"github.com/hori-ryota/go-strcase"
)

type TemplateParam struct {
	TypeDefs []*types.Named
}

var StructDefTemplate = template.Must(template.New("").Funcs(map[string]interface{}{
	"ToLowerCamel": ToLowerCamel,
	"ToUpperCamel": ToUpperCamel,
	"PrintDefs":    printDefs,
}).Parse(strings.TrimSpace(`
// Code generated by go-codegen api protobuf typescript_client httprpc structdef; DO NOT EDIT
{{ PrintDefs .TypeDefs}}
`)))

func ToUpperCamel(s string) string {
	return strcase.ToUpperCamelWithInitialisms(s, nil)
}

func ToLowerCamel(s string) string {
	return strcase.ToLowerCamelWithInitialisms(s, nil)
}

func printDefs(typeDefs []*types.Named) string {
	w := new(bytes.Buffer)
	alreadyDefined := make(map[string]bool, 100)
	for _, t := range typeDefs {
		printDef(w, t, alreadyDefined)
	}
	return w.String()
}

func printDef(w io.Writer, def *types.Named, alreadyDefined map[string]bool) {
	if alreadyDefined[ToUpperCamel(def.Obj().Name())] {
		return
	}

	needsMoreDef := make([]*types.Named, 0, 2)
	needsMoreEnumDef := make([]EnumDef, 0, 2)

	fmt.Fprintln(w, "")

	fmt.Fprintf(
		w,
		"export type %s = {\n",
		ToUpperCamel(def.Obj().Name()),
	)

	fields := typeutil.TypeToFields(def)
	for _, field := range fields {
		ft := field.Type()

		printTypeFmt := "%s"

	PEELING:
		for {
			if ft.Underlying().String() == "[]byte" {
				break
			}
			switch t := ft.Underlying().(type) {
			case *types.Pointer:
				printTypeFmt = fmt.Sprintf("%s?", printTypeFmt)
				ft = t.Elem()
			case *types.Slice:
				printTypeFmt = fmt.Sprintf("%s[]", printTypeFmt)
				ft = t.Elem()
			default:
				break PEELING
			}
		}

		var typeName string

		switch ft := ft.(type) {
		case *types.Struct:
			// for anonymous struct
			typeName = ToUpperCamel(def.Obj().Name()) + ToUpperCamel(field.Name())
			needsMoreDef = append(needsMoreDef, types.NewNamed(types.NewTypeName(token.NoPos, nil, typeName, nil), ft, nil))
		default:
			typeName = toTypeStr(ft, &needsMoreDef, &needsMoreEnumDef)
		}

		fmt.Fprintf(w, "  %s: %s;\n", ToLowerCamel(field.Name()), fmt.Sprintf(printTypeFmt, typeName))
	}
	fmt.Fprintln(w, "}")

	alreadyDefined[ToUpperCamel(def.Obj().Name())] = true

	for _, moreDef := range needsMoreDef {
		printDef(w, moreDef, alreadyDefined)
	}
	for _, enumDef := range needsMoreEnumDef {
		printEnumDef(w, enumDef, alreadyDefined)
	}
}

func printEnumDef(w io.Writer, def EnumDef, alreadyDefined map[string]bool) {
	if alreadyDefined[ToUpperCamel(def.Type.Obj().Name())] {
		return
	}

	fmt.Fprintln(w, "")

	fmt.Fprintf(
		w,
		"const %s = {\n",
		strcase.ToUpperSnake(def.Type.Obj().Name()),
	)

	for i, v := range def.Values {
		name := ToUpperCamel(v.Name())
		if strings.HasPrefix(name, ToLowerCamel(def.Type.Obj().Name())) {
			name = ToLowerCamel(strings.TrimPrefix(name, ToLowerCamel(def.Type.Obj().Name())))
		}
		fmt.Fprintf(w, "  %s: %s", name, v.Val().ExactString())
		if i != len(def.Values)-1 {
			fmt.Fprint(w, ",")
		}
		fmt.Fprint(w, "\n")
	}
	fmt.Fprintf(w, "} as const;\n")

	fmt.Fprintf(
		w,
		"export type %s = typeof %s[keyof typeof %s];\n",
		strcase.ToUpperSnake(def.Type.Obj().Name()),
		strcase.ToUpperSnake(def.Type.Obj().Name()),
		strcase.ToUpperSnake(def.Type.Obj().Name()),
	)

	alreadyDefined[ToUpperCamel(def.Type.Obj().Name())] = true
}

func AddIndent(s string, indent int) string {
	ss := strings.Split(s, "\n")
	for i := range ss {
		if ss[i] == "" {
			continue
		}
		ss[i] = strings.Repeat("    ", indent) + ss[i]
	}
	return strings.Join(ss, "\n")
}

func KnownTypesToTypescriptType(t types.Type) (string, bool) {
	underlyingType := t.Underlying().String()
	switch underlyingType {
	case "bool":
		return "boolean", true
	case "string", "[]byte":
		return "string", true
	case "float64", "float32",
		"int64", "int32", "int16", "int8", "int",
		"uint64", "uint32", "uint16", "uint8", "uint",
		"byte":
		return "number", true
	case "time.Time":
		return "number", true
	default:
		return "", false
	}
}

func toTypeStr(
	t types.Type,
	needsMoreDef *[]*types.Named,
	needsMoreEnumDef *[]EnumDef,
) string {
	if named, ok := t.(*types.Named); ok {
		enumValues := typeutil.TypeToEnumValues(named)
		if len(enumValues) > 0 {
			*needsMoreEnumDef = append(*needsMoreEnumDef, EnumDef{
				Type:   named,
				Values: enumValues,
			})
			return ToUpperCamel(named.Obj().Name())
		}
	}

	if typeStr, ok := KnownTypesToTypescriptType(t); ok {
		return typeStr
	}

	if named, ok := t.(*types.Named); ok {
		if _, ok := t.Underlying().(*types.Struct); ok {
			*needsMoreDef = append(*needsMoreDef, named)
			return ToUpperCamel(named.Obj().Name())
		}
	}
	panic(fmt.Errorf("unknown type '%s", t))
}

type EnumDef struct {
	Type   *types.Named
	Values []*types.Const
}
