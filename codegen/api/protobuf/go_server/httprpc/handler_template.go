package httprpc

import (
	"go/types"
	"sort"
	"strings"
	"text/template"

	"github.com/hori-ryota/go-codegen/util/typeutil"
	"github.com/hori-ryota/go-strcase"
)

type TemplateParam struct {
	PackageName    string
	ImportPackages string
	Services       []Service
	TypePrinter    typeutil.Printer
}

func extractActorDescriptorOrNil(f RPC) *types.Var {
	args := typeutil.FuncToParams(f.Func)
	if len(args) != 3 {
		return nil
	}
	return args[2]
}

func toActorParserTypeName(p typeutil.Printer, actor *types.Var) string {
	return strcase.ToUpperCamel(actor.Name()) + "To" + strcase.ToUpperCamel(p.PrintRelativeType(actor.Type())) + "Parser"
}

func toActorParseMethodName(p typeutil.Printer, actor *types.Var) string {
	return "Parse" + strcase.ToUpperCamel(actor.Name()) + "To" + strcase.ToUpperCamel(p.PrintRelativeType(actor.Type()))
}

var HandlerTemplate = template.Must(template.New("").Funcs(map[string]interface{}{
	"ToLowerCamel":                strcase.ToLowerCamel,
	"ToUpperCamel":                strcase.ToUpperCamel,
	"ExtractActorDescriptorOrNil": extractActorDescriptorOrNil,
	"ExtractActorDescriptors": func(rootParam TemplateParam) []*types.Var {
		actors := make(map[string]*types.Var, 10)
		for _, s := range rootParam.Services {
			for _, rpc := range s.RPCs {
				actor := extractActorDescriptorOrNil(rpc)
				if actor == nil {
					continue
				}
				n := actor.Name() + "_" + actor.Type().String()
				actors[n] = actor
			}
		}

		// sort
		names := make([]string, 0, len(actors))
		for k := range actors {
			names = append(names, k)
		}
		sort.Strings(names)
		results := make([]*types.Var, 0, len(names))
		for _, k := range names {
			results = append(results, actors[k])
		}

		return results
	},
	"ToActorParserTypeName":  toActorParserTypeName,
	"ToActorParseMethodName": toActorParseMethodName,
}).Parse(strings.TrimSpace(`
// Code generated by go-codegen api protobuf go_server httprpc; DO NOT EDIT

package {{.PackageName}}

{{.ImportPackages}}

{{$rootParam := .}}
{{$actors := ExtractActorDescriptors $rootParam}}

func NewHandlers(
	handleError func(w http.ResponseWriter, r *http.Request, err error),
	{{- range .Services}}
	{{ToLowerCamel .Obj.Name}}Factory {{ToUpperCamel .Obj.Name}}Factory,
	{{- end}}
	{{- range $actors}}
	{{ToLowerCamel (ToActorParserTypeName $rootParam.TypePrinter .)}} {{ToActorParserTypeName $rootParam.TypePrinter .}},
	{{- end}}
) Handlers {
	return Handlers{
		HandleError: handleError,
		{{- range .Services}}
		{{ToUpperCamel .Obj.Name}}Factory: {{ToLowerCamel .Obj.Name}}Factory,
		{{- end}}
		{{- range $actors}}
		{{ToUpperCamel (ToActorParserTypeName $rootParam.TypePrinter .)}}: {{ToLowerCamel (ToActorParserTypeName $rootParam.TypePrinter .)}},
		{{- end}}
	}
}

type Handlers struct {
	HandleError func(w http.ResponseWriter, r *http.Request, err error)
	{{- range .Services}}
	{{ToUpperCamel .Obj.Name}}Factory {{ToUpperCamel .Obj.Name}}Factory
	{{- end}}
	{{- range $actors }}
	{{ToUpperCamel (ToActorParserTypeName $rootParam.TypePrinter .)}} {{ToActorParserTypeName $rootParam.TypePrinter .}}
	{{- end}}
}

{{- range $actors }}
type {{ToActorParserTypeName $rootParam.TypePrinter .}} interface {
	 {{ToActorParseMethodName $rootParam.TypePrinter .}}(context.Context, *http.Request) ({{$rootParam.TypePrinter.PrintRelativeType .Type}}, error)
}
{{- end}}

{{- range .Services}}
type {{.Obj.Name}}Factory interface {
	Generate{{.Obj.Name}}(context.Context) ({{$rootParam.TypePrinter.PrintRelativeType .Named}}, error)
}
{{$service := .}}
{{- range .RPCs}}
func (h Handlers){{ToUpperCamel $service.Obj.Name}}{{.Name}}Handler(w http.ResponseWriter, r *http.Request) {
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		h.HandleError(w, r, err)
		return
	}

	inputProtoType := {{$rootParam.TypePrinter.PrintRelativeType .InputProtoType}}{}
	if err := proto.Unmarshal(body, &inputProtoType); err != nil {
		h.HandleError(w, r, err)
		return
	}
	input := {{$rootParam.TypePrinter.PrintConverterWitoutErrorCheck "inputProtoType" .InputProtoType .InputType}}
	
	usecase, err := h.{{$service.Obj.Name}}Factory.Generate{{$service.Obj.Name}}(r.Context())
	if err != nil {
		h.HandleError(w, r, err)
		return
	}

	{{- $actor := (ExtractActorDescriptorOrNil .)}}
	{{- if $actor}}
	actor, err := h.{{ToUpperCamel (ToActorParserTypeName $rootParam.TypePrinter $actor)}}.{{ToActorParseMethodName $rootParam.TypePrinter $actor}}(r.Context(), r)
	if err != nil {
		h.HandleError(w, r, err)
		return
	}
	{{- end}}

	{{- if .OutputType}}
	outputType, err := usecase.{{.Name}}(
		r.Context(), input,{{if $actor}} actor,{{end}}
	)
	if err != nil {
		h.HandleError(w, r, err)
		return
	}
	outputProtoType := {{$rootParam.TypePrinter.PrintConverterWitoutErrorCheck "outputType" .OutputType .OutputProtoType}}
	b, err := proto.Marshal(&outputProtoType)
	if err != nil {
		h.HandleError(w, r, err)
		return
	}
	if _, err := w.Write(b); err != nil {
		h.HandleError(w, r, err)
		return
	}
	return
	{{- else}}
	if err := usecase.{{.Name}}(
		r.Context(), input,{{if $actor}} actor,{{end}}
	); err != nil {
		h.HandleError(w, r, err)
		return
	}
	return
	{{- end}}
}

{{- end}}
{{- end}}

func NewMux(handler Handlers, middlewares ...func(http.Handler) http.Handler) *http.ServeMux {
	mux := http.NewServeMux()
	ApplyMux(mux, handler, middlewares...)
	return mux
}

func ApplyMux(mux *http.ServeMux, handler Handlers, middlewares ...func(http.Handler) http.Handler) {
	{{- range .Services}}
	{{$service := .}}
	{{- range .RPCs}}
	mux.Handle(
		"{{$service.Obj.Name}}/{{.Name}}",
		applyMiddleware(http.HandlerFunc(handler.{{ToUpperCamel $service.Obj.Name}}{{.Name}}Handler), middlewares...),
	)
	{{- end}}
	{{- end}}
}

func applyMiddleware(h http.Handler, middlewares ...func(http.Handler) http.Handler) http.Handler {
	for i := range middlewares {
		h = middlewares[len(middlewares)-i](h)
	}
	return h
}
`)))

var HandlerTemplateUsedPackages = []*types.Package{
	types.NewPackage("io/ioutil", "ioutil"),
	types.NewPackage("net/http", "http"),
}
