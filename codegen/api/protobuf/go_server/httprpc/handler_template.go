package httprpc

import (
	"go/token"
	"go/types"
	"strings"
	"text/template"

	"github.com/hori-ryota/go-codegen/util/typeutil"
	"github.com/hori-ryota/go-strcase"
)

type TemplateParam struct {
	PackageName           string
	ImportPackages        string
	Services              []Service
	TypePrinter           typeutil.Printer
	UsecaseFactoryPackage *types.Package
}

var HandlerTemplate = template.Must(template.New("").Funcs(map[string]interface{}{
	"ToLowerCamel": strcase.ToLowerCamel,
	"ToUpperCamel": strcase.ToUpperCamel,
	"ExtractActorDescriptorOrNil": func(f RPC) *types.Var {
		args := typeutil.FuncToParams(f.Func)
		if len(args) != 3 {
			return nil
		}
		return args[2]
	},
	"PrintUsecaseFactoryType": func(rootParam TemplateParam, usecase Service) string {
		return rootParam.TypePrinter.PrintRelativeType(types.NewNamed(
			types.NewTypeName(
				token.NoPos,
				rootParam.UsecaseFactoryPackage,
				strcase.ToUpperCamel(usecase.Obj().Name())+"Factory",
				nil,
			),
			nil, nil,
		))
	},
}).Parse(strings.TrimSpace(`
// Code generated by go-codegen api protobuf go_server httprpc; DO NOT EDIT

package {{.PackageName}}

{{.ImportPackages}}

{{$rootParam := .}}

func NewHandlers(
	handleError func(w http.ResponseWriter, r *http.Request, err error),
	{{- range .Services}}
	{{ToLowerCamel .Obj.Name}}Factory {{PrintUsecaseFactoryType $rootParam .}},
	{{- end}}
) Handlers {
	return Handlers{
		HandleError: handleError,
		{{- range .Services}}
		{{ToUpperCamel .Obj.Name}}Factory: {{ToLowerCamel .Obj.Name}}Factory,
		{{- end}}
	}
}

type Handlers struct {
	HandleError func(w http.ResponseWriter, r *http.Request, err error)
	{{- range .Services}}
	{{ToUpperCamel .Obj.Name}}Factory {{PrintUsecaseFactoryType $rootParam .}}
	{{- end}}
}

{{- range .Services}}
{{$service := .}}
{{- range .RPCs}}
func (h Handlers){{ToUpperCamel $service.Obj.Name}}{{.Name}}Handler(w http.ResponseWriter, r *http.Request) {
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		h.HandleError(w, r, err)
		return
	}

	inputProtoType := {{$rootParam.TypePrinter.PrintRelativeType .InputProtoType}}{}
	if err := proto.Unmarshal(body, &inputProtoType); err != nil {
		h.HandleError(w, r, err)
		return
	}
	input := {{$rootParam.TypePrinter.PrintConverterWitoutErrorCheck "inputProtoType" .InputProtoType .InputType}}
	
	usecase, err := h.{{$service.Obj.Name}}Factory.Generate(r.Context())
	if err != nil {
		h.HandleError(w, r, err)
		return
	}

	{{- $actor := (ExtractActorDescriptorOrNil .)}}
	{{- with $actor}}
	actor, err := Parse{{ToUpperCamel $actor.Name}}To{{ToUpperCamel ($rootParam.TypePrinter.PrintRelativeType $actor.Type)}}(r)
	if err != nil {
		h.HandleError(w, r, err)
		return
	}
	{{- end}}

	{{- if .OutputType}}
	outputType, err := usecase.{{.Name}}(
		r.Context(), input,{{if $actor}} actor,{{end}}
	)
	if err != nil {
		h.HandleError(w, r, err)
		return
	}
	outputProtoType := {{$rootParam.TypePrinter.PrintConverterWitoutErrorCheck "outputType" .OutputType .OutputProtoType}}
	b, err := proto.Marshal(&outputProtoType)
	if err != nil {
		h.HandleError(w, r, err)
		return
	}
	if _, err := w.Write(b); err != nil {
		h.HandleError(w, r, err)
		return
	}
	return
	{{- else}}
	if err := usecase.{{.Name}}(
		r.Context(), input,{{if $actor}} actor,{{end}}
	); err != nil {
		h.HandleError(w, r, err)
		return
	}
	return
	{{- end}}
}

{{- end}}
{{- end}}

func NewMux(handler Handlers, middlewares ...func(http.Handler) http.Handler) *http.ServeMux {
	mux := http.NewServeMux()
	ApplyMux(mux, handler, middlewares...)
	return mux
}

func ApplyMux(mux *http.ServeMux, handler Handlers, middlewares ...func(http.Handler) http.Handler) {
	{{- range .Services}}
	{{$service := .}}
	{{- range .RPCs}}
	mux.Handle(
		"{{$service.Obj.Name}}/{{.Name}}",
		applyMiddleware(http.HandlerFunc(handler.{{ToUpperCamel $service.Obj.Name}}{{.Name}}Handler), middlewares...),
	)
	{{- end}}
	{{- end}}
}

func applyMiddleware(h http.Handler, middlewares ...func(http.Handler) http.Handler) http.Handler {
	for i := range middlewares {
		h = middlewares[len(middlewares)-i](h)
	}
	return h
}
`)))

var HandlerTemplateUsedPackages = []*types.Package{
	types.NewPackage("io/ioutil", "ioutil"),
	types.NewPackage("net/http", "http"),
}
