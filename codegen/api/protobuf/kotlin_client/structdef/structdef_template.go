package structdef

import (
	"bytes"
	"fmt"
	"go/token"
	"go/types"
	"io"
	"strings"
	"text/template"

	"github.com/hori-ryota/go-codegen/util/typeutil"
	"github.com/hori-ryota/go-strcase"
)

type TemplateParam struct {
	KotlinPackage string
	TypeDefs      []*types.Named
}

var StructDefTemplate = template.Must(template.New("").Funcs(map[string]interface{}{
	"ToLowerCamel": strcase.ToLowerCamel,
	"ToUpperCamel": strcase.ToUpperCamel,
	"PrintDefs":    printDefs,
}).Parse(strings.TrimSpace(`
// Code generated by go-codegen api protobuf kotlin_client httprpc structdef; DO NOT EDIT

package {{.KotlinPackage}}

import kotlinx.serialization.SerialId
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
{{ PrintDefs .TypeDefs}}
`)))

func printDefs(typeDefs []*types.Named) string {
	w := new(bytes.Buffer)
	alreadyDefined := make(map[string]bool, 100)
	for _, t := range typeDefs {
		printDef(w, t, alreadyDefined)
	}
	return w.String()
}

func printDef(w io.Writer, def *types.Named, alreadyDefined map[string]bool) {
	if alreadyDefined[strcase.ToUpperCamel(def.Obj().Name())] {
		return
	}

	needsMoreDef := make([]*types.Named, 0, 2)
	needsMoreEnumDef := make([]EnumDef, 0, 2)

	fmt.Fprintln(w, "")
	fmt.Fprintln(w, "@Serializable")

	fmt.Fprintf(
		w,
		"data class %s(\n",
		strcase.ToUpperCamel(def.Obj().Name()),
	)

	fields := typeutil.TypeToFields(def)
	for i, field := range fields {
		ft := field.Type()

		printTypeFmt := "%s"

	PEELING:
		for {
			switch t := ft.Underlying().(type) {
			case *types.Pointer:
				ft = t.Elem()
			case *types.Slice:
				ft = t.Elem()
				printTypeFmt = fmt.Sprintf("List<%s>", printTypeFmt)
			default:
				break PEELING
			}
		}

		var typeName string

		switch ft := ft.(type) {
		case *types.Struct:
			// for anonymous struct
			typeName = strcase.ToUpperCamel(def.Obj().Name()) + strcase.ToUpperCamel(field.Name())
			needsMoreDef = append(needsMoreDef, types.NewNamed(types.NewTypeName(token.NoPos, nil, typeName, nil), ft, nil))
		default:
			typeName = toTypeStr(ft, &needsMoreDef, &needsMoreEnumDef)
		}

		fmt.Fprintf(w, "    @SerialId(%d)\n", i+1)
		fmt.Fprintf(w, "    @SerialName(\"%s\")\n", strcase.ToLowerSnake(field.Name()))
		fmt.Fprintf(w, "    val %s: %s", strcase.ToLowerCamel(field.Name()), fmt.Sprintf(printTypeFmt, typeName))
		if i != len(fields)-1 {
			fmt.Fprint(w, ",")
		}
		fmt.Fprint(w, "\n")
	}
	fmt.Fprintln(w, ")")

	alreadyDefined[strcase.ToUpperCamel(def.Obj().Name())] = true

	for _, moreDef := range needsMoreDef {
		printDef(w, moreDef, alreadyDefined)
	}
	for _, enumDef := range needsMoreEnumDef {
		printEnumDef(w, enumDef, alreadyDefined)
	}
}

func printEnumDef(w io.Writer, def EnumDef, alreadyDefined map[string]bool) {
	if alreadyDefined[strcase.ToUpperCamel(def.Type.Obj().Name())] {
		return
	}

	enumValueType, ok := KnownTypesToKotlinType(def.Type.Underlying())
	if !ok {
		panic(fmt.Errorf("unknown enum type '%s", def))
	}

	fmt.Fprintln(w, "")

	fmt.Fprintf(
		w,
		"enum class %s(val value: %s) {\n",
		strcase.ToUpperCamel(def.Type.Obj().Name()),
		enumValueType,
	)
	unknownValue := `"unknown"`
	if enumValueType != "String" {
		unknownValue = "0"
	}
	fmt.Fprintf(w, "    unknown(%s),\n", unknownValue)

	for i, v := range def.Values {
		name := strcase.ToLowerCamel(v.Name())
		if strings.HasPrefix(name, strcase.ToLowerCamel(def.Type.Obj().Name())) {
			name = strcase.ToLowerCamel(strings.TrimPrefix(name, strcase.ToLowerCamel(def.Type.Obj().Name())))
		}
		fmt.Fprintf(w, "    %s(%s)", name, v.Val().ExactString())
		if i != len(def.Values)-1 {
			fmt.Fprint(w, ",")
		}
		fmt.Fprint(w, "\n")
	}
	fmt.Fprintf(w, "}\n")

	alreadyDefined[strcase.ToUpperCamel(def.Type.Obj().Name())] = true
}

func AddIndent(s string, indent int) string {
	ss := strings.Split(s, "\n")
	for i := range ss {
		if ss[i] == "" {
			continue
		}
		ss[i] = strings.Repeat("    ", indent) + ss[i]
	}
	return strings.Join(ss, "\n")
}

func IsKnownNamedType(t *types.Named) bool {
	switch t.String() {
	case "time.Time", "time.Duration":
		return true
	}
	return false
}

func KnownTypesToKotlinType(t types.Type) (string, bool) {
	underlyingType := t.Underlying().String()
	switch underlyingType {
	case "bool":
		return "Boolean", true
	case "string":
		return "String", true
	case "float64":
		return "Double", true
	case "float32":
		return "Float", true
	case "int8", "int16":
		return "Short", true
	case "int32":
		return "Int", true
	case "int", "int64":
		return "Long", true
	case "uint8", "uint16":
		return "Short", true
	case "uint32":
		return "Int", true
	case "uint", "uint64":
		return "Long", true
	case "byte":
		return "Byte", true
	case "time.Time":
		return "Long", true
	default:
		return "", false
	}
}

func toTypeStr(
	t types.Type,
	needsMoreDef *[]*types.Named,
	needsMoreEnumDef *[]EnumDef,
) string {
	if named, ok := t.(*types.Named); ok {
		enumValues := typeutil.TypeToEnumValues(named)
		if len(enumValues) > 0 {
			*needsMoreEnumDef = append(*needsMoreEnumDef, EnumDef{
				Type:   named,
				Values: enumValues,
			})
			return strcase.ToUpperCamel(named.Obj().Name())
		}
	}

	if typeStr, ok := KnownTypesToKotlinType(t); ok {
		return typeStr
	}

	if named, ok := t.(*types.Named); ok {
		if _, ok := t.Underlying().(*types.Struct); ok {
			*needsMoreDef = append(*needsMoreDef, named)
			return strcase.ToUpperCamel(named.Obj().Name())
		}
	}
	panic(fmt.Errorf("unknown type '%s", t))
}

type EnumDef struct {
	Type   *types.Named
	Values []*types.Const
}
