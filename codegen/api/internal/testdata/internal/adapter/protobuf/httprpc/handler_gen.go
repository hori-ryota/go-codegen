// Code generated by go-codegen api protobuf go_server httprpc; DO NOT EDIT

package httprpc

import (
	context "context"
	ioutil "io/ioutil"
	http "net/http"

	proto "github.com/golang/protobuf/proto"
	protobuf "github.com/hori-ryota/go-codegen/codegen/api/internal/testdata/external/adapter/protobuf"
	application "github.com/hori-ryota/go-codegen/codegen/api/internal/testdata/internal/application"
	domain "github.com/hori-ryota/go-codegen/codegen/api/internal/testdata/internal/domain"
)

func NewHandlers(
	handleError func(w http.ResponseWriter, r *http.Request, err error),
	doingSomethingWithOutputAndActorUsecaseFactory DoingSomethingWithOutputAndActorUsecaseFactory,
	doingSomethingWithOutputWithoutActorUsecaseFactory DoingSomethingWithOutputWithoutActorUsecaseFactory,
	doingSomethingWithoutOutputAndActorUsecaseFactory DoingSomethingWithoutOutputAndActorUsecaseFactory,
	doingSomethingWithoutOutputWithActorUsecaseFactory DoingSomethingWithoutOutputWithActorUsecaseFactory,
	someActorToApplicationSomeActorDescriptionParser SomeActorToApplicationSomeActorDescriptionParser,
) Handlers {
	return Handlers{
		HandleError: handleError,
		DoingSomethingWithOutputAndActorUsecaseFactory:     doingSomethingWithOutputAndActorUsecaseFactory,
		DoingSomethingWithOutputWithoutActorUsecaseFactory: doingSomethingWithOutputWithoutActorUsecaseFactory,
		DoingSomethingWithoutOutputAndActorUsecaseFactory:  doingSomethingWithoutOutputAndActorUsecaseFactory,
		DoingSomethingWithoutOutputWithActorUsecaseFactory: doingSomethingWithoutOutputWithActorUsecaseFactory,
		SomeActorToApplicationSomeActorDescriptionParser:   someActorToApplicationSomeActorDescriptionParser,
	}
}

type Handlers struct {
	HandleError                                        func(w http.ResponseWriter, r *http.Request, err error)
	DoingSomethingWithOutputAndActorUsecaseFactory     DoingSomethingWithOutputAndActorUsecaseFactory
	DoingSomethingWithOutputWithoutActorUsecaseFactory DoingSomethingWithOutputWithoutActorUsecaseFactory
	DoingSomethingWithoutOutputAndActorUsecaseFactory  DoingSomethingWithoutOutputAndActorUsecaseFactory
	DoingSomethingWithoutOutputWithActorUsecaseFactory DoingSomethingWithoutOutputWithActorUsecaseFactory
	SomeActorToApplicationSomeActorDescriptionParser   SomeActorToApplicationSomeActorDescriptionParser
}
type SomeActorToApplicationSomeActorDescriptionParser interface {
	ParseSomeActorToApplicationSomeActorDescription(context.Context, *http.Request) (application.SomeActorDescription, error)
}
type DoingSomethingWithOutputAndActorUsecaseFactory interface {
	GenerateDoingSomethingWithOutputAndActorUsecase(context.Context) (application.DoingSomethingWithOutputAndActorUsecase, error)
}
type StaticDoingSomethingWithOutputAndActorUsecaseFactory struct {
	usecase application.DoingSomethingWithOutputAndActorUsecase
}

func NewStaticDoingSomethingWithOutputAndActorUsecaseFactory(usecase application.DoingSomethingWithOutputAndActorUsecase) StaticDoingSomethingWithOutputAndActorUsecaseFactory {
	return StaticDoingSomethingWithOutputAndActorUsecaseFactory{usecase: usecase}
}
func (f StaticDoingSomethingWithOutputAndActorUsecaseFactory) GenerateDoingSomethingWithOutputAndActorUsecase(ctx context.Context) (application.DoingSomethingWithOutputAndActorUsecase, error) {
	return f.usecase, nil
}

func (h Handlers) DoingSomethingWithOutputAndActorUsecaseDoSomethingWithOutputAndActorHandler(w http.ResponseWriter, r *http.Request) {
	if h.DoingSomethingWithOutputAndActorUsecaseFactory == nil {
		w.WriteHeader(http.StatusNotImplemented)
		return
	}

	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		h.HandleError(w, r, err)
		return
	}

	inputProtoType := protobuf.DoingSomethingWithOutputAndActorUsecaseInput{}
	if err := proto.Unmarshal(body, &inputProtoType); err != nil {
		h.HandleError(w, r, err)
		return
	}
	input := func() application.DoingSomethingWithOutputAndActorUsecaseInput {
		m := application.NewDoingSomethingWithOutputAndActorUsecaseInput(
			inputProtoType.GetStringParam(),
			int(inputProtoType.GetIntParam()),
			inputProtoType.GetInt64Param(),
			uint(inputProtoType.GetUintParam()),
			inputProtoType.GetUint64Param(),
			inputProtoType.GetFloat32Param(),
			inputProtoType.GetFloat64Param(),
			inputProtoType.GetBytesParam(),
			struct{ StringParam string }{
				StringParam: inputProtoType.GetAnonymousNestedStructParam().GetStringParam(),
			},
			func() application.NamedSomeType {
				m := application.NewNamedSomeType(
					inputProtoType.GetNamedNestedStructParam().GetStringParam(),
				)

				return m
			}(),
			func(s protobuf.StringEnum) domain.StringEnum {
				switch s {
				case protobuf.StringEnum_STRING_A:
					return domain.StringA
				case protobuf.StringEnum_STRING_B:
					return domain.StringB
				case protobuf.StringEnum_STRING_C:
					return domain.StringC

				default:
					var t0 domain.StringEnum
					return t0
				}
			}(inputProtoType.GetStringEnumParam()),
			func(s protobuf.IntEnum) domain.IntEnum {
				switch s {
				case protobuf.IntEnum_INT_ONE:
					return domain.IntOne
				case protobuf.IntEnum_INT_THREE:
					return domain.IntThree
				case protobuf.IntEnum_INT_TWO:
					return domain.IntTwo

				default:
					var t0 domain.IntEnum
					return t0
				}
			}(inputProtoType.GetIntEnumParam()),
			inputProtoType.GetStringSliceParam(),
			func() []int {
				t0 := make([]int, len(inputProtoType.GetIntSliceParam()))
				for i0 := range t0 {
					t0[i0] = int(inputProtoType.GetIntSliceParam()[i0])
				}
				return t0
			}(),
			inputProtoType.GetInt64SliceParam(),
			func() []uint {
				t0 := make([]uint, len(inputProtoType.GetUintSliceParam()))
				for i0 := range t0 {
					t0[i0] = uint(inputProtoType.GetUintSliceParam()[i0])
				}
				return t0
			}(),
			inputProtoType.GetUint64SliceParam(),
			inputProtoType.GetFloat32SliceParam(),
			inputProtoType.GetFloat64SliceParam(),
			inputProtoType.GetBytesSliceParam(),
			func() []struct{ StringParam string } {
				t0 := make([]struct{ StringParam string }, len(inputProtoType.GetAnonymousNestedStructSliceParam()))
				for i0 := range t0 {
					t0[i0] = struct{ StringParam string }{
						StringParam: inputProtoType.GetAnonymousNestedStructSliceParam()[i0].GetStringParam(),
					}
				}
				return t0
			}(),
			func() []application.NamedSomeType {
				t0 := make([]application.NamedSomeType, len(inputProtoType.GetNamedNestedStructSliceParam()))
				for i0 := range t0 {
					t0[i0] = func() application.NamedSomeType {
						m := application.NewNamedSomeType(
							inputProtoType.GetNamedNestedStructSliceParam()[i0].GetStringParam(),
						)

						return m
					}()
				}
				return t0
			}(),
			func() []domain.StringEnum {
				t0 := make([]domain.StringEnum, len(inputProtoType.GetStringEnumSliceParam()))
				for i0 := range t0 {
					t0[i0] = func(s protobuf.StringEnum) domain.StringEnum {
						switch s {
						case protobuf.StringEnum_STRING_A:
							return domain.StringA
						case protobuf.StringEnum_STRING_B:
							return domain.StringB
						case protobuf.StringEnum_STRING_C:
							return domain.StringC

						default:
							var t1 domain.StringEnum
							return t1
						}
					}(inputProtoType.GetStringEnumSliceParam()[i0])
				}
				return t0
			}(),
			func() []domain.IntEnum {
				t0 := make([]domain.IntEnum, len(inputProtoType.GetIntEnumSliceParam()))
				for i0 := range t0 {
					t0[i0] = func(s protobuf.IntEnum) domain.IntEnum {
						switch s {
						case protobuf.IntEnum_INT_ONE:
							return domain.IntOne
						case protobuf.IntEnum_INT_THREE:
							return domain.IntThree
						case protobuf.IntEnum_INT_TWO:
							return domain.IntTwo

						default:
							var t1 domain.IntEnum
							return t1
						}
					}(inputProtoType.GetIntEnumSliceParam()[i0])
				}
				return t0
			}(),
		)

		return m
	}()

	if h.DoingSomethingWithOutputAndActorUsecaseFactory == nil {
		h.HandleError(w, r, err)
		return
	}
	usecase, err := h.DoingSomethingWithOutputAndActorUsecaseFactory.GenerateDoingSomethingWithOutputAndActorUsecase(r.Context())
	if err != nil {
		h.HandleError(w, r, err)
		return
	}
	actor, err := h.SomeActorToApplicationSomeActorDescriptionParser.ParseSomeActorToApplicationSomeActorDescription(r.Context(), r)
	if err != nil {
		h.HandleError(w, r, err)
		return
	}
	outputType, err := usecase.DoSomethingWithOutputAndActor(
		r.Context(), input, actor,
	)
	if err != nil {
		h.HandleError(w, r, err)
		return
	}
	outputProtoType := protobuf.DoingSomethingWithOutputAndActorUsecaseOutput{
		StringParam: outputType.StringParam(),
	}
	b, err := proto.Marshal(&outputProtoType)
	if err != nil {
		h.HandleError(w, r, err)
		return
	}
	if _, err := w.Write(b); err != nil {
		h.HandleError(w, r, err)
		return
	}
	return
}

type DoingSomethingWithOutputWithoutActorUsecaseFactory interface {
	GenerateDoingSomethingWithOutputWithoutActorUsecase(context.Context) (application.DoingSomethingWithOutputWithoutActorUsecase, error)
}
type StaticDoingSomethingWithOutputWithoutActorUsecaseFactory struct {
	usecase application.DoingSomethingWithOutputWithoutActorUsecase
}

func NewStaticDoingSomethingWithOutputWithoutActorUsecaseFactory(usecase application.DoingSomethingWithOutputWithoutActorUsecase) StaticDoingSomethingWithOutputWithoutActorUsecaseFactory {
	return StaticDoingSomethingWithOutputWithoutActorUsecaseFactory{usecase: usecase}
}
func (f StaticDoingSomethingWithOutputWithoutActorUsecaseFactory) GenerateDoingSomethingWithOutputWithoutActorUsecase(ctx context.Context) (application.DoingSomethingWithOutputWithoutActorUsecase, error) {
	return f.usecase, nil
}

func (h Handlers) DoingSomethingWithOutputWithoutActorUsecaseDoSomethingWithOutputWithoutActorHandler(w http.ResponseWriter, r *http.Request) {
	if h.DoingSomethingWithOutputWithoutActorUsecaseFactory == nil {
		w.WriteHeader(http.StatusNotImplemented)
		return
	}

	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		h.HandleError(w, r, err)
		return
	}

	inputProtoType := protobuf.DoingSomethingWithOutputWithoutActorUsecaseInput{}
	if err := proto.Unmarshal(body, &inputProtoType); err != nil {
		h.HandleError(w, r, err)
		return
	}
	input := func() application.DoingSomethingWithOutputWithoutActorUsecaseInput {
		m := application.NewDoingSomethingWithOutputWithoutActorUsecaseInput(
			inputProtoType.GetStringParam(),
		)

		return m
	}()

	if h.DoingSomethingWithOutputWithoutActorUsecaseFactory == nil {
		h.HandleError(w, r, err)
		return
	}
	usecase, err := h.DoingSomethingWithOutputWithoutActorUsecaseFactory.GenerateDoingSomethingWithOutputWithoutActorUsecase(r.Context())
	if err != nil {
		h.HandleError(w, r, err)
		return
	}
	outputType, err := usecase.DoSomethingWithOutputWithoutActor(
		r.Context(), input,
	)
	if err != nil {
		h.HandleError(w, r, err)
		return
	}
	outputProtoType := protobuf.DoingSomethingWithOutputWithoutActorUsecaseOutput{
		StringParam: outputType.StringParam(),
	}
	b, err := proto.Marshal(&outputProtoType)
	if err != nil {
		h.HandleError(w, r, err)
		return
	}
	if _, err := w.Write(b); err != nil {
		h.HandleError(w, r, err)
		return
	}
	return
}

type DoingSomethingWithoutOutputAndActorUsecaseFactory interface {
	GenerateDoingSomethingWithoutOutputAndActorUsecase(context.Context) (application.DoingSomethingWithoutOutputAndActorUsecase, error)
}
type StaticDoingSomethingWithoutOutputAndActorUsecaseFactory struct {
	usecase application.DoingSomethingWithoutOutputAndActorUsecase
}

func NewStaticDoingSomethingWithoutOutputAndActorUsecaseFactory(usecase application.DoingSomethingWithoutOutputAndActorUsecase) StaticDoingSomethingWithoutOutputAndActorUsecaseFactory {
	return StaticDoingSomethingWithoutOutputAndActorUsecaseFactory{usecase: usecase}
}
func (f StaticDoingSomethingWithoutOutputAndActorUsecaseFactory) GenerateDoingSomethingWithoutOutputAndActorUsecase(ctx context.Context) (application.DoingSomethingWithoutOutputAndActorUsecase, error) {
	return f.usecase, nil
}

func (h Handlers) DoingSomethingWithoutOutputAndActorUsecaseDoSomethingWithoutOutputAndActorHandler(w http.ResponseWriter, r *http.Request) {
	if h.DoingSomethingWithoutOutputAndActorUsecaseFactory == nil {
		w.WriteHeader(http.StatusNotImplemented)
		return
	}

	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		h.HandleError(w, r, err)
		return
	}

	inputProtoType := protobuf.DoingSomethingWithoutOutputAndActorUsecaseInput{}
	if err := proto.Unmarshal(body, &inputProtoType); err != nil {
		h.HandleError(w, r, err)
		return
	}
	input := func() application.DoingSomethingWithoutOutputAndActorUsecaseInput {
		m := application.NewDoingSomethingWithoutOutputAndActorUsecaseInput(
			inputProtoType.GetStringParam(),
		)

		return m
	}()

	if h.DoingSomethingWithoutOutputAndActorUsecaseFactory == nil {
		h.HandleError(w, r, err)
		return
	}
	usecase, err := h.DoingSomethingWithoutOutputAndActorUsecaseFactory.GenerateDoingSomethingWithoutOutputAndActorUsecase(r.Context())
	if err != nil {
		h.HandleError(w, r, err)
		return
	}
	if err := usecase.DoSomethingWithoutOutputAndActor(
		r.Context(), input,
	); err != nil {
		h.HandleError(w, r, err)
		return
	}
	return
}

type DoingSomethingWithoutOutputWithActorUsecaseFactory interface {
	GenerateDoingSomethingWithoutOutputWithActorUsecase(context.Context) (application.DoingSomethingWithoutOutputWithActorUsecase, error)
}
type StaticDoingSomethingWithoutOutputWithActorUsecaseFactory struct {
	usecase application.DoingSomethingWithoutOutputWithActorUsecase
}

func NewStaticDoingSomethingWithoutOutputWithActorUsecaseFactory(usecase application.DoingSomethingWithoutOutputWithActorUsecase) StaticDoingSomethingWithoutOutputWithActorUsecaseFactory {
	return StaticDoingSomethingWithoutOutputWithActorUsecaseFactory{usecase: usecase}
}
func (f StaticDoingSomethingWithoutOutputWithActorUsecaseFactory) GenerateDoingSomethingWithoutOutputWithActorUsecase(ctx context.Context) (application.DoingSomethingWithoutOutputWithActorUsecase, error) {
	return f.usecase, nil
}

func (h Handlers) DoingSomethingWithoutOutputWithActorUsecaseDoSomethingWithoutOutputWithActorHandler(w http.ResponseWriter, r *http.Request) {
	if h.DoingSomethingWithoutOutputWithActorUsecaseFactory == nil {
		w.WriteHeader(http.StatusNotImplemented)
		return
	}

	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		h.HandleError(w, r, err)
		return
	}

	inputProtoType := protobuf.DoingSomethingWithoutOutputWithActorUsecaseInput{}
	if err := proto.Unmarshal(body, &inputProtoType); err != nil {
		h.HandleError(w, r, err)
		return
	}
	input := func() application.DoingSomethingWithoutOutputWithActorUsecaseInput {
		m := application.NewDoingSomethingWithoutOutputWithActorUsecaseInput(
			inputProtoType.GetStringParam(),
		)

		return m
	}()

	if h.DoingSomethingWithoutOutputWithActorUsecaseFactory == nil {
		h.HandleError(w, r, err)
		return
	}
	usecase, err := h.DoingSomethingWithoutOutputWithActorUsecaseFactory.GenerateDoingSomethingWithoutOutputWithActorUsecase(r.Context())
	if err != nil {
		h.HandleError(w, r, err)
		return
	}
	actor, err := h.SomeActorToApplicationSomeActorDescriptionParser.ParseSomeActorToApplicationSomeActorDescription(r.Context(), r)
	if err != nil {
		h.HandleError(w, r, err)
		return
	}
	if err := usecase.DoSomethingWithoutOutputWithActor(
		r.Context(), input, actor,
	); err != nil {
		h.HandleError(w, r, err)
		return
	}
	return
}

func NewMux(handler Handlers, middlewares ...func(http.Handler) http.Handler) *http.ServeMux {
	mux := http.NewServeMux()
	ApplyMux(mux, handler, middlewares...)
	return mux
}

func ApplyMux(mux *http.ServeMux, handler Handlers, middlewares ...func(http.Handler) http.Handler) {

	mux.Handle(
		"DoingSomethingWithOutputAndActorUsecase/DoSomethingWithOutputAndActor",
		applyMiddleware(http.HandlerFunc(handler.DoingSomethingWithOutputAndActorUsecaseDoSomethingWithOutputAndActorHandler), middlewares...),
	)

	mux.Handle(
		"DoingSomethingWithOutputWithoutActorUsecase/DoSomethingWithOutputWithoutActor",
		applyMiddleware(http.HandlerFunc(handler.DoingSomethingWithOutputWithoutActorUsecaseDoSomethingWithOutputWithoutActorHandler), middlewares...),
	)

	mux.Handle(
		"DoingSomethingWithoutOutputAndActorUsecase/DoSomethingWithoutOutputAndActor",
		applyMiddleware(http.HandlerFunc(handler.DoingSomethingWithoutOutputAndActorUsecaseDoSomethingWithoutOutputAndActorHandler), middlewares...),
	)

	mux.Handle(
		"DoingSomethingWithoutOutputWithActorUsecase/DoSomethingWithoutOutputWithActor",
		applyMiddleware(http.HandlerFunc(handler.DoingSomethingWithoutOutputWithActorUsecaseDoSomethingWithoutOutputWithActorHandler), middlewares...),
	)
}

func applyMiddleware(h http.Handler, middlewares ...func(http.Handler) http.Handler) http.Handler {
	for i := range middlewares {
		h = middlewares[len(middlewares)-i](h)
	}
	return h
}
