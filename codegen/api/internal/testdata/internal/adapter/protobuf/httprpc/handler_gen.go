// Code generated by go-codegen api protobuf go_server httprpc; DO NOT EDIT

package httprpc

import (
	"context"
	"encoding/json"
	"io/ioutil"
	"net/http"

	"github.com/hori-ryota/go-codegen/codegen/api/internal/testdata/external/adapter/protobuf"
	"github.com/hori-ryota/go-codegen/codegen/api/internal/testdata/internal/application"
	"github.com/hori-ryota/go-codegen/codegen/api/internal/testdata/internal/domain"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
)

type ErrorType string

const (
	FailedToReadRequestError          ErrorType = "failed to read request"
	FailedToUnmarshalRequestError     ErrorType = "failed to unmarshal request"
	FailedToGenerateUsecaseError      ErrorType = "failed to generate usecase"
	FailedToParseActorDescriptorError ErrorType = "failed to parse actor descriptor"
	FromUsecaseError                  ErrorType = "from usecase error"
	FailedToMarshalResponseError      ErrorType = "failed to marshal response"
	FailedToWriteResponseError        ErrorType = "failed to write response"
)

type BodyMarshaler interface {
	Marshal(v proto.Message) (data []byte, err error)
	ContentType() string
}

type bodyMarshaler struct {
	marshalFunc func(v proto.Message) (data []byte, err error)
	contentType string
}

func (m bodyMarshaler) Marshal(v proto.Message) ([]byte, error) {
	return m.marshalFunc(v)
}

func (m bodyMarshaler) ContentType() string {
	return m.contentType
}

func NewBodyMarshaler(
	marshalFunc func(v proto.Message) (data []byte, err error),
	contentType string,
) BodyMarshaler {
	return bodyMarshaler{
		marshalFunc: marshalFunc,
		contentType: contentType,
	}
}

func NewProtoBodyMarshaler() BodyMarshaler {
	return NewBodyMarshaler(
		proto.Marshal,
		"application/protobuf",
	)
}

func NewJSONBodyMarshaler() BodyMarshaler {
	return NewBodyMarshaler(
		func(v proto.Message) ([]byte, error) {
			return json.Marshal(v)
		},
		"application/json",
	)
}

func NewProtoJSONBodyMarshaler() BodyMarshaler {
	return NewBodyMarshaler(
		func(v proto.Message) ([]byte, error) {
			return protojson.Marshal(v)
		},
		"application/json",
	)
}

type BodyUnmarshaler interface {
	Unmarshal(data []byte, v proto.Message) error
}

type bodyUnmarshaler struct {
	unmarshalFunc func(data []byte, v proto.Message) error
}

func (m bodyUnmarshaler) Unmarshal(data []byte, v proto.Message) error {
	return m.unmarshalFunc(data, v)
}

func NewBodyUnmarshaler(
	unmarshalFunc func(data []byte, v proto.Message) error,
) BodyUnmarshaler {
	return bodyUnmarshaler{
		unmarshalFunc: unmarshalFunc,
	}
}

func NewProtoBodyUnmarshaler() BodyUnmarshaler {
	return NewBodyUnmarshaler(
		proto.Unmarshal,
	)
}

func NewProtoJSONBodyUnmarshaler() BodyUnmarshaler {
	return NewBodyUnmarshaler(
		func(data []byte, v proto.Message) error {
			return protojson.Unmarshal(data, v)
		},
	)
}

func NewHandlers(
	handleError func(w http.ResponseWriter, r *http.Request, errorType ErrorType, err error),
	bodyMarshaler BodyMarshaler,
	bodyUnmarshaler BodyUnmarshaler,
	doingSomethingWithOutputAndActorUsecaseFactory DoingSomethingWithOutputAndActorUsecaseFactory,
	doingSomethingWithOutputWithoutActorUsecaseFactory DoingSomethingWithOutputWithoutActorUsecaseFactory,
	doingSomethingWithoutOutputAndActorUsecaseFactory DoingSomethingWithoutOutputAndActorUsecaseFactory,
	doingSomethingWithoutOutputWithActorUsecaseFactory DoingSomethingWithoutOutputWithActorUsecaseFactory,
	someActorToApplicationSomeActorDescriptionParser SomeActorToApplicationSomeActorDescriptionParser,
) Handlers {
	return Handlers{
		HandleError:     handleError,
		bodyMarshaler:   bodyMarshaler,
		bodyUnmarshaler: bodyUnmarshaler,
		DoingSomethingWithOutputAndActorUsecaseFactory:     doingSomethingWithOutputAndActorUsecaseFactory,
		DoingSomethingWithOutputWithoutActorUsecaseFactory: doingSomethingWithOutputWithoutActorUsecaseFactory,
		DoingSomethingWithoutOutputAndActorUsecaseFactory:  doingSomethingWithoutOutputAndActorUsecaseFactory,
		DoingSomethingWithoutOutputWithActorUsecaseFactory: doingSomethingWithoutOutputWithActorUsecaseFactory,
		SomeActorToApplicationSomeActorDescriptionParser:   someActorToApplicationSomeActorDescriptionParser,
	}
}

type Handlers struct {
	HandleError                                        func(w http.ResponseWriter, r *http.Request, errorType ErrorType, err error)
	bodyMarshaler                                      BodyMarshaler
	bodyUnmarshaler                                    BodyUnmarshaler
	DoingSomethingWithOutputAndActorUsecaseFactory     DoingSomethingWithOutputAndActorUsecaseFactory
	DoingSomethingWithOutputWithoutActorUsecaseFactory DoingSomethingWithOutputWithoutActorUsecaseFactory
	DoingSomethingWithoutOutputAndActorUsecaseFactory  DoingSomethingWithoutOutputAndActorUsecaseFactory
	DoingSomethingWithoutOutputWithActorUsecaseFactory DoingSomethingWithoutOutputWithActorUsecaseFactory
	SomeActorToApplicationSomeActorDescriptionParser   SomeActorToApplicationSomeActorDescriptionParser
}
type SomeActorToApplicationSomeActorDescriptionParser interface {
	ParseSomeActorToApplicationSomeActorDescription(context.Context, *http.Request) (application.SomeActorDescription, error)
}
type DoingSomethingWithOutputAndActorUsecaseFactory interface {
	GenerateDoingSomethingWithOutputAndActorUsecase(context.Context) (application.DoingSomethingWithOutputAndActorUsecase, error)
}
type StaticDoingSomethingWithOutputAndActorUsecaseFactory struct {
	usecase application.DoingSomethingWithOutputAndActorUsecase
}

func NewStaticDoingSomethingWithOutputAndActorUsecaseFactory(usecase application.DoingSomethingWithOutputAndActorUsecase) StaticDoingSomethingWithOutputAndActorUsecaseFactory {
	return StaticDoingSomethingWithOutputAndActorUsecaseFactory{usecase: usecase}
}
func (f StaticDoingSomethingWithOutputAndActorUsecaseFactory) GenerateDoingSomethingWithOutputAndActorUsecase(ctx context.Context) (application.DoingSomethingWithOutputAndActorUsecase, error) {
	return f.usecase, nil
}

func (h Handlers) DoingSomethingWithOutputAndActorUsecaseDoSomethingWithOutputAndActorHandler(w http.ResponseWriter, r *http.Request) {
	if h.DoingSomethingWithOutputAndActorUsecaseFactory == nil {
		w.WriteHeader(http.StatusNotImplemented)
		return
	}

	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		h.HandleError(w, r, FailedToReadRequestError, err)
		return
	}

	inputProtoType := protobuf.DoingSomethingWithOutputAndActorUsecaseInput{}
	if err := h.bodyUnmarshaler.Unmarshal(body, &inputProtoType); err != nil {
		h.HandleError(w, r, FailedToUnmarshalRequestError, err)
		return
	}
	input := func() application.DoingSomethingWithOutputAndActorUsecaseInput {
		m := application.NewDoingSomethingWithOutputAndActorUsecaseInput(
			inputProtoType.GetStringParam(),
			int(inputProtoType.GetIntParam()),
			inputProtoType.GetInt64Param(),
			uint(inputProtoType.GetUintParam()),
			inputProtoType.GetUint64Param(),
			inputProtoType.GetFloat32Param(),
			inputProtoType.GetFloat64Param(),
			inputProtoType.GetBytesParam(),
			struct{ StringParam string }{
				StringParam: inputProtoType.GetAnonymousNestedStructParam().GetStringParam(),
			},
			func() application.NamedSomeType {
				m := application.NewNamedSomeType(
					inputProtoType.GetNamedNestedStructParam().GetStringParam(),
				)

				return m
			}(),
			func(s protobuf.StringEnum) domain.StringEnum {
				switch s {
				case protobuf.StringEnum_STRING_A:
					return domain.StringA
				case protobuf.StringEnum_STRING_B:
					return domain.StringB
				case protobuf.StringEnum_STRING_C:
					return domain.StringC

				default:
					var t0 domain.StringEnum
					return t0
				}
			}(inputProtoType.GetStringEnumParam()),
			func(s protobuf.IntEnum) domain.IntEnum {
				switch s {
				case protobuf.IntEnum_INT_ONE:
					return domain.IntOne
				case protobuf.IntEnum_INT_THREE:
					return domain.IntThree
				case protobuf.IntEnum_INT_TWO:
					return domain.IntTwo

				default:
					var t0 domain.IntEnum
					return t0
				}
			}(inputProtoType.GetIntEnumParam()),
			inputProtoType.GetStringSliceParam(),
			func() []int {
				t0 := make([]int, len(inputProtoType.GetIntSliceParam()))
				for i0 := range t0 {
					t0[i0] = int(inputProtoType.GetIntSliceParam()[i0])
				}
				return t0
			}(),
			inputProtoType.GetInt64SliceParam(),
			func() []uint {
				t0 := make([]uint, len(inputProtoType.GetUintSliceParam()))
				for i0 := range t0 {
					t0[i0] = uint(inputProtoType.GetUintSliceParam()[i0])
				}
				return t0
			}(),
			inputProtoType.GetUint64SliceParam(),
			inputProtoType.GetFloat32SliceParam(),
			inputProtoType.GetFloat64SliceParam(),
			inputProtoType.GetBytesSliceParam(),
			func() []struct{ StringParam string } {
				t0 := make([]struct{ StringParam string }, len(inputProtoType.GetAnonymousNestedStructSliceParam()))
				for i0 := range t0 {
					t0[i0] = struct{ StringParam string }{
						StringParam: inputProtoType.GetAnonymousNestedStructSliceParam()[i0].GetStringParam(),
					}
				}
				return t0
			}(),
			func() []application.NamedSomeType {
				t0 := make([]application.NamedSomeType, len(inputProtoType.GetNamedNestedStructSliceParam()))
				for i0 := range t0 {
					t0[i0] = func() application.NamedSomeType {
						m := application.NewNamedSomeType(
							inputProtoType.GetNamedNestedStructSliceParam()[i0].GetStringParam(),
						)

						return m
					}()
				}
				return t0
			}(),
			func() []domain.StringEnum {
				t0 := make([]domain.StringEnum, len(inputProtoType.GetStringEnumSliceParam()))
				for i0 := range t0 {
					t0[i0] = func(s protobuf.StringEnum) domain.StringEnum {
						switch s {
						case protobuf.StringEnum_STRING_A:
							return domain.StringA
						case protobuf.StringEnum_STRING_B:
							return domain.StringB
						case protobuf.StringEnum_STRING_C:
							return domain.StringC

						default:
							var t1 domain.StringEnum
							return t1
						}
					}(inputProtoType.GetStringEnumSliceParam()[i0])
				}
				return t0
			}(),
			func() []domain.IntEnum {
				t0 := make([]domain.IntEnum, len(inputProtoType.GetIntEnumSliceParam()))
				for i0 := range t0 {
					t0[i0] = func(s protobuf.IntEnum) domain.IntEnum {
						switch s {
						case protobuf.IntEnum_INT_ONE:
							return domain.IntOne
						case protobuf.IntEnum_INT_THREE:
							return domain.IntThree
						case protobuf.IntEnum_INT_TWO:
							return domain.IntTwo

						default:
							var t1 domain.IntEnum
							return t1
						}
					}(inputProtoType.GetIntEnumSliceParam()[i0])
				}
				return t0
			}(),
		)

		return m
	}()

	usecase, err := h.DoingSomethingWithOutputAndActorUsecaseFactory.GenerateDoingSomethingWithOutputAndActorUsecase(r.Context())
	if err != nil {
		h.HandleError(w, r, FailedToGenerateUsecaseError, err)
		return
	}
	actor, err := h.SomeActorToApplicationSomeActorDescriptionParser.ParseSomeActorToApplicationSomeActorDescription(r.Context(), r)
	if err != nil {
		h.HandleError(w, r, FailedToParseActorDescriptorError, err)
		return
	}
	outputType, err := usecase.DoSomethingWithOutputAndActor(
		r.Context(), input, actor,
	)
	if err != nil {
		h.HandleError(w, r, FromUsecaseError, err)
		return
	}
	outputProtoType := protobuf.DoingSomethingWithOutputAndActorUsecaseOutput{
		StringParam: outputType.StringParam(),
	}
	b, err := h.bodyMarshaler.Marshal(&outputProtoType)
	if err != nil {
		h.HandleError(w, r, FailedToMarshalResponseError, err)
		return
	}
	w.Header().Set("Content-Type", h.bodyMarshaler.ContentType())
	if _, err := w.Write(b); err != nil {
		h.HandleError(w, r, FailedToWriteResponseError, err)
		return
	}
	return
}

type DoingSomethingWithOutputWithoutActorUsecaseFactory interface {
	GenerateDoingSomethingWithOutputWithoutActorUsecase(context.Context) (application.DoingSomethingWithOutputWithoutActorUsecase, error)
}
type StaticDoingSomethingWithOutputWithoutActorUsecaseFactory struct {
	usecase application.DoingSomethingWithOutputWithoutActorUsecase
}

func NewStaticDoingSomethingWithOutputWithoutActorUsecaseFactory(usecase application.DoingSomethingWithOutputWithoutActorUsecase) StaticDoingSomethingWithOutputWithoutActorUsecaseFactory {
	return StaticDoingSomethingWithOutputWithoutActorUsecaseFactory{usecase: usecase}
}
func (f StaticDoingSomethingWithOutputWithoutActorUsecaseFactory) GenerateDoingSomethingWithOutputWithoutActorUsecase(ctx context.Context) (application.DoingSomethingWithOutputWithoutActorUsecase, error) {
	return f.usecase, nil
}

func (h Handlers) DoingSomethingWithOutputWithoutActorUsecaseDoSomethingWithOutputWithoutActorHandler(w http.ResponseWriter, r *http.Request) {
	if h.DoingSomethingWithOutputWithoutActorUsecaseFactory == nil {
		w.WriteHeader(http.StatusNotImplemented)
		return
	}

	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		h.HandleError(w, r, FailedToReadRequestError, err)
		return
	}

	inputProtoType := protobuf.DoingSomethingWithOutputWithoutActorUsecaseInput{}
	if err := h.bodyUnmarshaler.Unmarshal(body, &inputProtoType); err != nil {
		h.HandleError(w, r, FailedToUnmarshalRequestError, err)
		return
	}
	input := func() application.DoingSomethingWithOutputWithoutActorUsecaseInput {
		m := application.NewDoingSomethingWithOutputWithoutActorUsecaseInput(
			inputProtoType.GetStringParam(),
		)

		return m
	}()

	usecase, err := h.DoingSomethingWithOutputWithoutActorUsecaseFactory.GenerateDoingSomethingWithOutputWithoutActorUsecase(r.Context())
	if err != nil {
		h.HandleError(w, r, FailedToGenerateUsecaseError, err)
		return
	}
	outputType, err := usecase.DoSomethingWithOutputWithoutActor(
		r.Context(), input,
	)
	if err != nil {
		h.HandleError(w, r, FromUsecaseError, err)
		return
	}
	outputProtoType := protobuf.DoingSomethingWithOutputWithoutActorUsecaseOutput{
		StringParam: outputType.StringParam(),
	}
	b, err := h.bodyMarshaler.Marshal(&outputProtoType)
	if err != nil {
		h.HandleError(w, r, FailedToMarshalResponseError, err)
		return
	}
	w.Header().Set("Content-Type", h.bodyMarshaler.ContentType())
	if _, err := w.Write(b); err != nil {
		h.HandleError(w, r, FailedToWriteResponseError, err)
		return
	}
	return
}

type DoingSomethingWithoutOutputAndActorUsecaseFactory interface {
	GenerateDoingSomethingWithoutOutputAndActorUsecase(context.Context) (application.DoingSomethingWithoutOutputAndActorUsecase, error)
}
type StaticDoingSomethingWithoutOutputAndActorUsecaseFactory struct {
	usecase application.DoingSomethingWithoutOutputAndActorUsecase
}

func NewStaticDoingSomethingWithoutOutputAndActorUsecaseFactory(usecase application.DoingSomethingWithoutOutputAndActorUsecase) StaticDoingSomethingWithoutOutputAndActorUsecaseFactory {
	return StaticDoingSomethingWithoutOutputAndActorUsecaseFactory{usecase: usecase}
}
func (f StaticDoingSomethingWithoutOutputAndActorUsecaseFactory) GenerateDoingSomethingWithoutOutputAndActorUsecase(ctx context.Context) (application.DoingSomethingWithoutOutputAndActorUsecase, error) {
	return f.usecase, nil
}

func (h Handlers) DoingSomethingWithoutOutputAndActorUsecaseDoSomethingWithoutOutputAndActorHandler(w http.ResponseWriter, r *http.Request) {
	if h.DoingSomethingWithoutOutputAndActorUsecaseFactory == nil {
		w.WriteHeader(http.StatusNotImplemented)
		return
	}

	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		h.HandleError(w, r, FailedToReadRequestError, err)
		return
	}

	inputProtoType := protobuf.DoingSomethingWithoutOutputAndActorUsecaseInput{}
	if err := h.bodyUnmarshaler.Unmarshal(body, &inputProtoType); err != nil {
		h.HandleError(w, r, FailedToUnmarshalRequestError, err)
		return
	}
	input := func() application.DoingSomethingWithoutOutputAndActorUsecaseInput {
		m := application.NewDoingSomethingWithoutOutputAndActorUsecaseInput(
			inputProtoType.GetStringParam(),
		)

		return m
	}()

	usecase, err := h.DoingSomethingWithoutOutputAndActorUsecaseFactory.GenerateDoingSomethingWithoutOutputAndActorUsecase(r.Context())
	if err != nil {
		h.HandleError(w, r, FailedToGenerateUsecaseError, err)
		return
	}
	if err := usecase.DoSomethingWithoutOutputAndActor(
		r.Context(), input,
	); err != nil {
		h.HandleError(w, r, FromUsecaseError, err)
		return
	}
	return
}

type DoingSomethingWithoutOutputWithActorUsecaseFactory interface {
	GenerateDoingSomethingWithoutOutputWithActorUsecase(context.Context) (application.DoingSomethingWithoutOutputWithActorUsecase, error)
}
type StaticDoingSomethingWithoutOutputWithActorUsecaseFactory struct {
	usecase application.DoingSomethingWithoutOutputWithActorUsecase
}

func NewStaticDoingSomethingWithoutOutputWithActorUsecaseFactory(usecase application.DoingSomethingWithoutOutputWithActorUsecase) StaticDoingSomethingWithoutOutputWithActorUsecaseFactory {
	return StaticDoingSomethingWithoutOutputWithActorUsecaseFactory{usecase: usecase}
}
func (f StaticDoingSomethingWithoutOutputWithActorUsecaseFactory) GenerateDoingSomethingWithoutOutputWithActorUsecase(ctx context.Context) (application.DoingSomethingWithoutOutputWithActorUsecase, error) {
	return f.usecase, nil
}

func (h Handlers) DoingSomethingWithoutOutputWithActorUsecaseDoSomethingWithoutOutputWithActorHandler(w http.ResponseWriter, r *http.Request) {
	if h.DoingSomethingWithoutOutputWithActorUsecaseFactory == nil {
		w.WriteHeader(http.StatusNotImplemented)
		return
	}

	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		h.HandleError(w, r, FailedToReadRequestError, err)
		return
	}

	inputProtoType := protobuf.DoingSomethingWithoutOutputWithActorUsecaseInput{}
	if err := h.bodyUnmarshaler.Unmarshal(body, &inputProtoType); err != nil {
		h.HandleError(w, r, FailedToUnmarshalRequestError, err)
		return
	}
	input := func() application.DoingSomethingWithoutOutputWithActorUsecaseInput {
		m := application.NewDoingSomethingWithoutOutputWithActorUsecaseInput(
			inputProtoType.GetStringParam(),
		)

		return m
	}()

	usecase, err := h.DoingSomethingWithoutOutputWithActorUsecaseFactory.GenerateDoingSomethingWithoutOutputWithActorUsecase(r.Context())
	if err != nil {
		h.HandleError(w, r, FailedToGenerateUsecaseError, err)
		return
	}
	actor, err := h.SomeActorToApplicationSomeActorDescriptionParser.ParseSomeActorToApplicationSomeActorDescription(r.Context(), r)
	if err != nil {
		h.HandleError(w, r, FailedToParseActorDescriptorError, err)
		return
	}
	if err := usecase.DoSomethingWithoutOutputWithActor(
		r.Context(), input, actor,
	); err != nil {
		h.HandleError(w, r, FromUsecaseError, err)
		return
	}
	return
}

func NewMux(handler Handlers, middlewares ...func(http.Handler) http.Handler) *http.ServeMux {
	mux := http.NewServeMux()
	ApplyMux(mux, handler, middlewares...)
	return mux
}

func ApplyMux(mux *http.ServeMux, handler Handlers, middlewares ...func(http.Handler) http.Handler) {

	mux.Handle(
		"/DoingSomethingWithOutputAndActorUsecase/DoSomethingWithOutputAndActor",
		applyMiddleware(http.HandlerFunc(handler.DoingSomethingWithOutputAndActorUsecaseDoSomethingWithOutputAndActorHandler), middlewares...),
	)

	mux.Handle(
		"/DoingSomethingWithOutputWithoutActorUsecase/DoSomethingWithOutputWithoutActor",
		applyMiddleware(http.HandlerFunc(handler.DoingSomethingWithOutputWithoutActorUsecaseDoSomethingWithOutputWithoutActorHandler), middlewares...),
	)

	mux.Handle(
		"/DoingSomethingWithoutOutputAndActorUsecase/DoSomethingWithoutOutputAndActor",
		applyMiddleware(http.HandlerFunc(handler.DoingSomethingWithoutOutputAndActorUsecaseDoSomethingWithoutOutputAndActorHandler), middlewares...),
	)

	mux.Handle(
		"/DoingSomethingWithoutOutputWithActorUsecase/DoSomethingWithoutOutputWithActor",
		applyMiddleware(http.HandlerFunc(handler.DoingSomethingWithoutOutputWithActorUsecaseDoSomethingWithoutOutputWithActorHandler), middlewares...),
	)
}

func applyMiddleware(h http.Handler, middlewares ...func(http.Handler) http.Handler) http.Handler {
	for i := range middlewares {
		h = middlewares[len(middlewares)-i-1](h)
	}
	return h
}
