// Code generated by go-codegen api protobuf go_client httprpc; DO NOT EDIT

package httprpc

import (
	bytes "bytes"
	context "context"
	json "encoding/json"
	io "io"
	ioutil "io/ioutil"
	http "net/http"
	url "net/url"
	path "path"

	proto "github.com/golang/protobuf/proto"
	protobuf "github.com/hori-ryota/go-codegen/codegen/api/internal/testdata/external/adapter/protobuf"
	zaperr "github.com/hori-ryota/zaperr"
	zap "go.uber.org/zap"
)

type BodyMarshaler interface {
	Marshal(v proto.Message) (data []byte, err error)
	ContentType() string
}

type bodyMarshaler struct {
	marshalFunc func(v proto.Message) (data []byte, err error)
	contentType string
}

func (m bodyMarshaler) Marshal(v proto.Message) ([]byte, error) {
	return m.marshalFunc(v)
}

func (m bodyMarshaler) ContentType() string {
	return m.contentType
}

func NewBodyMarshaler(
	marshalFunc func(v proto.Message) (data []byte, err error),
	contentType string,
) BodyMarshaler {
	return bodyMarshaler{
		marshalFunc: marshalFunc,
		contentType: contentType,
	}
}

func NewJSONBodyMarshaler() BodyMarshaler {
	return NewBodyMarshaler(
		func(v proto.Message) ([]byte, error) {
			return json.Marshal(v)
		},
		"application/json",
	)
}

func NewProtoBodyMarshaler() BodyMarshaler {
	return NewBodyMarshaler(
		proto.Marshal,
		"application/protobuf",
	)
}

func NewJSONPbBodyMarshaler() BodyMarshaler {
	return NewBodyMarshaler(
		func(v proto.Message) ([]byte, error) {
			return json.Marshal(v)
		},
		"application/json",
	)
}

type BodyUnmarshaler interface {
	Unmarshal(data []byte, v proto.Message) error
}

type bodyUnmarshaler struct {
	unmarshalFunc func(data []byte, v proto.Message) error
}

func (m bodyUnmarshaler) Unmarshal(data []byte, v proto.Message) error {
	return m.unmarshalFunc(data, v)
}

func NewBodyUnmarshaler(
	unmarshalFunc func(data []byte, v proto.Message) error,
) BodyUnmarshaler {
	return bodyUnmarshaler{
		unmarshalFunc: unmarshalFunc,
	}
}

func NewJSONBodyUnmarshaler() BodyUnmarshaler {
	return NewBodyUnmarshaler(
		func(data []byte, v proto.Message) error {
			return json.Unmarshal(data, v)
		},
	)
}

func NewProtoBodyUnmarshaler() BodyUnmarshaler {
	return NewBodyUnmarshaler(
		proto.Unmarshal,
	)
}

func NewClient(
	httpClient *http.Client,
	urlBase url.URL,
	bodyMarshaler BodyMarshaler,
	bodyUnmarshaler BodyUnmarshaler,
	handleErrorResponse func(resp *http.Response) error,
) Client {
	return Client{
		httpClient:          httpClient,
		urlBase:             urlBase,
		bodyMarshaler:       bodyMarshaler,
		bodyUnmarshaler:     bodyUnmarshaler,
		handleErrorResponse: handleErrorResponse,
	}
}

type Client struct {
	httpClient          *http.Client
	urlBase             url.URL
	bodyMarshaler       BodyMarshaler
	bodyUnmarshaler     BodyUnmarshaler
	handleErrorResponse func(resp *http.Response) error
}

func (c Client) DoSomethingWithOutputAndActor(ctx context.Context, input DoingSomethingWithOutputAndActorUsecaseInput) (output DoingSomethingWithOutputAndActorUsecaseOutput, err error) {
	u := c.urlBase
	u.Path = path.Join(u.Path, "DoingSomethingWithOutputAndActorUsecase/DoSomethingWithOutputAndActor")

	inputProtoType := protobuf.DoingSomethingWithOutputAndActorUsecaseInput{
		StringParam:  input.StringParam,
		IntParam:     int64(input.IntParam),
		Int64Param:   input.Int64Param,
		UintParam:    uint64(input.UintParam),
		Uint64Param:  input.Uint64Param,
		Float32Param: input.Float32Param,
		Float64Param: input.Float64Param,
		BytesParam:   input.BytesParam,
		AnonymousNestedStructParam: func() *protobuf.DoingSomethingWithOutputAndActorUsecaseInput_AnonymousNestedStructParam {
			t0 := protobuf.DoingSomethingWithOutputAndActorUsecaseInput_AnonymousNestedStructParam{
				StringParam: input.AnonymousNestedStructParam.StringParam,
			}
			return &t0
		}(),
		NamedNestedStructParam: func() *protobuf.NamedSomeType {
			t0 := protobuf.NamedSomeType{
				StringParam: input.NamedNestedStructParam.StringParam,
			}
			return &t0
		}(),
		StringEnumParam: func(s StringEnum) protobuf.StringEnum {
			switch s {
			case StringA:
				return protobuf.StringEnum_STRING_A
			case StringB:
				return protobuf.StringEnum_STRING_B
			case StringC:
				return protobuf.StringEnum_STRING_C

			default:
				var t0 protobuf.StringEnum
				return t0
			}
		}(input.StringEnumParam),
		IntEnumParam: func(s IntEnum) protobuf.IntEnum {
			switch s {
			case IntOne:
				return protobuf.IntEnum_INT_ONE
			case IntThree:
				return protobuf.IntEnum_INT_THREE
			case IntTwo:
				return protobuf.IntEnum_INT_TWO

			default:
				var t0 protobuf.IntEnum
				return t0
			}
		}(input.IntEnumParam),
		StringSliceParam: input.StringSliceParam,
		IntSliceParam: func() []int64 {
			t0 := make([]int64, len(input.IntSliceParam))
			for i0 := range t0 {
				t0[i0] = int64(input.IntSliceParam[i0])
			}
			return t0
		}(),
		Int64SliceParam: input.Int64SliceParam,
		UintSliceParam: func() []uint64 {
			t0 := make([]uint64, len(input.UintSliceParam))
			for i0 := range t0 {
				t0[i0] = uint64(input.UintSliceParam[i0])
			}
			return t0
		}(),
		Uint64SliceParam:  input.Uint64SliceParam,
		Float32SliceParam: input.Float32SliceParam,
		Float64SliceParam: input.Float64SliceParam,
		BytesSliceParam:   input.BytesSliceParam,
		AnonymousNestedStructSliceParam: func() []*protobuf.DoingSomethingWithOutputAndActorUsecaseInput_AnonymousNestedStructSliceParam {
			t0 := make([]*protobuf.DoingSomethingWithOutputAndActorUsecaseInput_AnonymousNestedStructSliceParam, len(input.AnonymousNestedStructSliceParam))
			for i0 := range t0 {
				t0[i0] = func() *protobuf.DoingSomethingWithOutputAndActorUsecaseInput_AnonymousNestedStructSliceParam {
					t1 := protobuf.DoingSomethingWithOutputAndActorUsecaseInput_AnonymousNestedStructSliceParam{
						StringParam: input.AnonymousNestedStructSliceParam[i0].StringParam,
					}
					return &t1
				}()
			}
			return t0
		}(),
		NamedNestedStructSliceParam: func() []*protobuf.NamedSomeType {
			t0 := make([]*protobuf.NamedSomeType, len(input.NamedNestedStructSliceParam))
			for i0 := range t0 {
				t0[i0] = func() *protobuf.NamedSomeType {
					t1 := protobuf.NamedSomeType{
						StringParam: input.NamedNestedStructSliceParam[i0].StringParam,
					}
					return &t1
				}()
			}
			return t0
		}(),
		StringEnumSliceParam: func() []protobuf.StringEnum {
			t0 := make([]protobuf.StringEnum, len(input.StringEnumSliceParam))
			for i0 := range t0 {
				t0[i0] = func(s StringEnum) protobuf.StringEnum {
					switch s {
					case StringA:
						return protobuf.StringEnum_STRING_A
					case StringB:
						return protobuf.StringEnum_STRING_B
					case StringC:
						return protobuf.StringEnum_STRING_C

					default:
						var t1 protobuf.StringEnum
						return t1
					}
				}(input.StringEnumSliceParam[i0])
			}
			return t0
		}(),
		IntEnumSliceParam: func() []protobuf.IntEnum {
			t0 := make([]protobuf.IntEnum, len(input.IntEnumSliceParam))
			for i0 := range t0 {
				t0[i0] = func(s IntEnum) protobuf.IntEnum {
					switch s {
					case IntOne:
						return protobuf.IntEnum_INT_ONE
					case IntThree:
						return protobuf.IntEnum_INT_THREE
					case IntTwo:
						return protobuf.IntEnum_INT_TWO

					default:
						var t1 protobuf.IntEnum
						return t1
					}
				}(input.IntEnumSliceParam[i0])
			}
			return t0
		}(),
	}
	b, err := c.bodyMarshaler.Marshal(&inputProtoType)
	if err != nil {
		return output, err
	}
	r, err := http.NewRequest("POST", u.String(), bytes.NewReader(b))
	if err != nil {
		return output, err
	}
	r = r.WithContext(ctx)
	r.Header.Set("Content-Type", c.bodyMarshaler.ContentType())

	resp, err := c.httpClient.Do(r)
	if err != nil {
		return output, err
	}
	defer func() {
		io.Copy(ioutil.Discard, resp.Body)
		resp.Body.Close()
	}()

	if resp.StatusCode >= 400 {
		err := c.handleErrorResponse(resp)
		return output, err
	}
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		err = zaperr.Wrap(err, "failed to read response body", zap.Int("statusCode", resp.StatusCode))
		return output, err
	}
	outputProtoType := protobuf.DoingSomethingWithOutputAndActorUsecaseOutput{}
	if err := c.bodyUnmarshaler.Unmarshal(body, &outputProtoType); err != nil {
		err = zaperr.Wrap(err, "failed to parse response body", zap.String("body", string(body)))
		return output, err
	}
	return func() DoingSomethingWithOutputAndActorUsecaseOutput {
		m := NewDoingSomethingWithOutputAndActorUsecaseOutput(
			outputProtoType.GetStringParam(),
		)

		return m
	}(), nil
}

func (c Client) DoSomethingWithOutputWithoutActor(ctx context.Context, input DoingSomethingWithOutputWithoutActorUsecaseInput) (output DoingSomethingWithOutputWithoutActorUsecaseOutput, err error) {
	u := c.urlBase
	u.Path = path.Join(u.Path, "DoingSomethingWithOutputWithoutActorUsecase/DoSomethingWithOutputWithoutActor")

	inputProtoType := protobuf.DoingSomethingWithOutputWithoutActorUsecaseInput{
		StringParam: input.StringParam,
	}
	b, err := c.bodyMarshaler.Marshal(&inputProtoType)
	if err != nil {
		return output, err
	}
	r, err := http.NewRequest("POST", u.String(), bytes.NewReader(b))
	if err != nil {
		return output, err
	}
	r = r.WithContext(ctx)
	r.Header.Set("Content-Type", c.bodyMarshaler.ContentType())

	resp, err := c.httpClient.Do(r)
	if err != nil {
		return output, err
	}
	defer func() {
		io.Copy(ioutil.Discard, resp.Body)
		resp.Body.Close()
	}()

	if resp.StatusCode >= 400 {
		err := c.handleErrorResponse(resp)
		return output, err
	}
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		err = zaperr.Wrap(err, "failed to read response body", zap.Int("statusCode", resp.StatusCode))
		return output, err
	}
	outputProtoType := protobuf.DoingSomethingWithOutputWithoutActorUsecaseOutput{}
	if err := c.bodyUnmarshaler.Unmarshal(body, &outputProtoType); err != nil {
		err = zaperr.Wrap(err, "failed to parse response body", zap.String("body", string(body)))
		return output, err
	}
	return func() DoingSomethingWithOutputWithoutActorUsecaseOutput {
		m := NewDoingSomethingWithOutputWithoutActorUsecaseOutput(
			outputProtoType.GetStringParam(),
		)

		return m
	}(), nil
}

func (c Client) DoSomethingWithoutOutputAndActor(ctx context.Context, input DoingSomethingWithoutOutputAndActorUsecaseInput) error {
	u := c.urlBase
	u.Path = path.Join(u.Path, "DoingSomethingWithoutOutputAndActorUsecase/DoSomethingWithoutOutputAndActor")

	inputProtoType := protobuf.DoingSomethingWithoutOutputAndActorUsecaseInput{
		StringParam: input.StringParam,
	}
	b, err := c.bodyMarshaler.Marshal(&inputProtoType)
	if err != nil {
		return err
	}
	r, err := http.NewRequest("POST", u.String(), bytes.NewReader(b))
	if err != nil {
		return err
	}
	r = r.WithContext(ctx)
	r.Header.Set("Content-Type", c.bodyMarshaler.ContentType())

	resp, err := c.httpClient.Do(r)
	if err != nil {
		return err
	}
	defer func() {
		io.Copy(ioutil.Discard, resp.Body)
		resp.Body.Close()
	}()

	if resp.StatusCode >= 400 {
		err := c.handleErrorResponse(resp)
		return err
	}
	return nil
}

func (c Client) DoSomethingWithoutOutputWithActor(ctx context.Context, input DoingSomethingWithoutOutputWithActorUsecaseInput) error {
	u := c.urlBase
	u.Path = path.Join(u.Path, "DoingSomethingWithoutOutputWithActorUsecase/DoSomethingWithoutOutputWithActor")

	inputProtoType := protobuf.DoingSomethingWithoutOutputWithActorUsecaseInput{
		StringParam: input.StringParam,
	}
	b, err := c.bodyMarshaler.Marshal(&inputProtoType)
	if err != nil {
		return err
	}
	r, err := http.NewRequest("POST", u.String(), bytes.NewReader(b))
	if err != nil {
		return err
	}
	r = r.WithContext(ctx)
	r.Header.Set("Content-Type", c.bodyMarshaler.ContentType())

	resp, err := c.httpClient.Do(r)
	if err != nil {
		return err
	}
	defer func() {
		io.Copy(ioutil.Discard, resp.Body)
		resp.Body.Close()
	}()

	if resp.StatusCode >= 400 {
		err := c.handleErrorResponse(resp)
		return err
	}
	return nil
}
