package go_accessor

import (
	"bytes"
	"go/types"
	"reflect"
	"strings"
	"text/template"

	"github.com/hori-ryota/go-codegen/util/gocodeutil"
	"github.com/hori-ryota/go-codegen/util/typeutil"
	"github.com/hori-ryota/go-strcase"
	"golang.org/x/tools/go/loader"
)

func Generate(pkgInfo *loader.PackageInfo) (string, error) {
	allImported := typeutil.AllImported(pkgInfo)
	pkgPathToName := make(map[string]string, len(allImported))
	for _, imported := range allImported {
		pkgPathToName[imported.Path()] = imported.Name()
	}

	printer := typeutil.NewPrinter(pkgInfo.Pkg)
	printer.SetPkgPathToName(pkgPathToName)
	b := new(bytes.Buffer)
	for _, name := range pkgInfo.Pkg.Scope().Names() {
		obj := pkgInfo.Pkg.Scope().Lookup(name)
		named, ok := obj.Type().(*types.Named)
		if !ok {
			continue
		}
		if named.Obj().Name() != name {
			continue
		}
		strct, ok := named.Underlying().(*types.Struct)
		if !ok {
			continue
		}
		fields := typeutil.TypeToFields(strct)
		tags := typeutil.TypeToTags(strct)
		for i, field := range fields {
			tag := reflect.StructTag(strings.Trim(tags[i], "`"))
			for _, accessorTmpl := range accessorTmpls {
				methodNamesText, hasTag := tag.Lookup(accessorTmpl.tagKey)
				if !hasTag {
					continue
				}

				fieldName := field.Name()
				methodNames := []string{accessorTmpl.defaultMethodName(fieldName)}
				if len(methodNamesText) != 0 {
					methodNames = strings.Split(methodNamesText, ",")
				}

				for _, methodName := range methodNames {
					if err := accessorTmpl.tmpl.Execute(b, tmplParam{
						StructName: obj.Name(),
						MethodName: methodName,
						FieldType:  printer.PrintRelativeType(field.Type()),
						FieldName:  fieldName,
					}); err != nil {
						panic(err)
					}
				}
			}
		}
	}
	if b.Len() == 0 {
		return "", nil
	}

	out := new(bytes.Buffer)

	err := template.Must(template.New("out").Parse(`
			// Code generated by go-codegen go_accessor; DO NOT EDIT.

			package {{ .PackageName }}

			{{ .ImportPackages }}

			{{ .Body }}
		`)).Execute(out, map[string]string{
		"PackageName":    pkgInfo.Pkg.Name(),
		"ImportPackages": typeutil.FmtImports(allImported, pkgInfo.Pkg),
		"Body":           b.String(),
	})
	if err != nil {
		return "", err
	}

	dst, err := gocodeutil.FormatGoFileFromString(out.String())
	if err != nil {
		return out.String(), err
	}
	return dst, nil
}

type Field struct {
	Type       types.Type
	Name       string
	ConstValue string
}

type tmplParam struct {
	StructName string
	MethodName string
	FieldType  string
	FieldName  string
}

var accessorTmpls = []struct {
	tagKey            string
	tmpl              *template.Template
	defaultMethodName func(filedName string) string
}{
	{
		tagKey: "getter",
		tmpl: template.Must(template.New("getter").Parse(`
func (m {{ .StructName }}) {{ .MethodName }}() {{ .FieldType }} {
				return m.{{ .FieldName }}
			}
		`)),
		defaultMethodName: strcase.ToUpperCamel,
	},
	{
		tagKey: "setter",
		tmpl: template.Must(template.New("getter").Parse(`
func (m *{{ .StructName }}) {{ .MethodName }}(s {{ .FieldType }}) {
				m.{{ .FieldName }} = s
			}
		`)),
		defaultMethodName: func(fieldName string) string {
			return "Set" + strcase.ToUpperCamel(fieldName)
		},
	},
}
